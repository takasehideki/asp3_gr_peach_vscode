
		TOPPERS/ASP3カーネル
		ARM依存部 ユーザーズマニュアル

		対応バージョン: Release 3.2
		最終更新: 2017年7月20日

このドキュメントは，TOPPERS/ASP3カーネルのARM依存部を使用するために必要
な事項を説明するものである．

----------------------------------------------------------------------
 TOPPERS/ASP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Advanced Standard Profile Kernel

 Copyright (C) 2014-2017 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 $Id: arm_user.txt 805 2017-07-20 17:48:05Z ertl-hiro $
----------------------------------------------------------------------

○目次

１．ARM依存部の概要
	1.1 ARM依存部のディレクトリ構成
	1.2 ARMコア依存部
	1.3 MPCoreチップ依存部
	1.4 RZ/A1チップ依存部
	1.5 GIC依存部
	1.6 その他の依存部
２．ターゲット定義事項の規定
	2.1 データ型に関する規定
	2.2 割込み処理に関する規定
		2.2.1 GIC依存部における割込み処理に関する規定
		2.2.2 RZ/A1チップ依存部における割込み処理に関する規定
	2.3 CPU例外処理に関する規定
	2.4 タイマに関する規定
		2.4.1 MPCoreチップ依存部
		2.4.2 RZ/A1チップ依存部におけるタイマに関する規定
	2.5 その他の規定・制約
	2.6 動的生成機能拡張のサポートに関する規定
３．使用上の注意とヒント
	3.1 MMUの設定
	3.2 CPU例外の原因の追及方法
	3.3 パフォーマンスモニタによる性能評価
４．リファレンス
	4.1 ディレクトリ構成・ファイル構成
	4.2 バージョン履歴


１．ARM依存部の概要

ARM依存部は，TOPPERS/ASP3カーネルのターゲット依存部の中で，ARMコアおよ
びそれを用いたチップに共通に使用できる部分である．

1.1 ARM依存部のディレクトリ構成

ARM依存部の置かれているディレクトリは次の通り．

	arch/
		arm_gcc/common/		ARMコア依存部など
		arm_gcc/mpcore/		MPCoreチップ依存部
		arm_gcc/rza1/		RZ/A1チップ依存部
		arm_gcc/doc/		ARM依存部に関するドキュメント

1.2 ARMコア依存部

ARMコア依存部は，ARMv4，ARMv5，ARMv6，ARMv7-A，ARMv7-Rに準拠したプロセッ
サコアを持つターゲットシステム（チップ）に共通に使用できる部分である．

コア略称等は次の通り．

	コア略称：arm
	開発環境略称：gcc

ARMコア依存部（GNU開発環境向け）は，arch/arm_gcc/commonに置かれている．

1.3 MPCoreチップ依存部

MPCoreチップ依存部は，ARM MPCoreアーキテクチャに基づいたチップに共通に
使用できる部分である．MPCoreチップ依存部には，MPCoreが持つタイマとウォッ
チドッグの操作や，SCU（スヌープ制御ユニット）の操作などが含まれる．

チップ略称等は次の通り．

	チップ略称：mpcore
	開発環境略称：gcc

MPCoreチップ依存部は，GIC依存部を用いている．そのため，このドキュメント
中でGIC依存部に関して記述されたことは，MPCoreチップ依存部にも適用される．

MPCoreチップ依存部（GNU開発環境向け）は，arch/arm_gcc/mpcoreに置かれて
いる．

1.4 RZ/A1チップ依存部

RZ/A1チップ依存部は，ARM Cortex-A9コアを搭載したルネサス RZ/Aシリーズの
チップに共通に使用できる部分である．RZ/A1チップ依存部には，RZ/Aシリーズ
のチップが持つOSタイマ（OSTM）の操作や，FIFO内蔵シリアルコミュニケーショ
ンインタフェース（SCIF）の操作などが含まれる．

チップ略称等は次の通り．

	チップ略称：rza1
	開発環境略称：gcc

RZ/A1チップ依存部は，GIC依存部を用いている．そのため，このドキュメント
中でGIC依存部に関して記述されたことは，RZ/A1チップ依存部にも適用される．
ただし，RZ/Aシリーズの割込みコントローラは，標準のGICに対して独自の拡張
を加えているため，それに対応するため，GIC依存部に拡張を加えている．

RZ/Aシリーズは，ARM Cortex-A9 MPCoreを用いているが，MPCoreが持つタイマ
とウォッチドッグを使用できないこと，シングルコアでありSCUの操作が不要で
あることから，MPCoreチップ依存部は用いていない．

RZ/A1チップ依存部（GNU開発環境向け）は，arch/arm_gcc/rza1に置かれている．

1.5 GIC依存部

GIC依存部は，ARMの標準的な割込みコントローラの1つであるGIC（ARM
Generic Interrupt Controller）を用いたチップに共通に使用できる部分であ
る．GIC依存部（GNU開発環境向け）は，arch/arm_gcc/commonに置かれている．

1.6 その他のターゲット依存部

以下に挙げるARMの標準的なIP向けの定義ファイルや操作ライブラリ等が，
arch/arm_gcc/commonに置かれている．

・ARM L2キャッシュコントローラ（PL310）に関する定義と操作ライブラリ
・ARM Dual-Timer Module（SP804）に関する定義ファイル
・ARM PrimCell UART（PL011）用 簡易デバイスドライバ


２．ターゲット定義事項の規定

2.1 データ型に関する規定

ターゲット依存のデータ型のサイズは次の通り．

	int_t			32ビット
	long_t			32ビット

	char			8ビット
	int_least8_t	8ビット
	void *			32ビット
	intptr_t		32ビット
	size_t			32ビット

ターゲット依存のデータ型の有無は次の通り．

	int8_t，uint8_t			あり
	int64_t，uint64_t		あり
	int128_t，uint128_t		なし
	float32_t				あり
	double64_t				あり

2.2 割込み処理に関する規定

ARMコア依存部の標準では，IRQをカーネル管理の割込み，FIQをカーネル管理外
の割込みと扱う．ただし，SafeGのセキュアモードでASP3カーネルを動作させる
場合には，FIQをカーネル管理の割込みとして扱い，カーネル管理外の割込みは
サポートしない．FIQに対する割込みハンドラは，DEF_INHではなく，DEF_EXCを
用いて登録する．

割込みサービスルーチンまたは割込みハンドラを登録していない割込みが発生
した場合，デフォルトの割込みハンドラが実行される．ターゲット依存部で変
更していない場合，デフォルトの割込みハンドラでは，未登録の割込みが発生
したことをシステムログに出力する．

2.2.1 GIC依存部における割込み処理に関する規定

GIC依存部では，GICに対する割込みのID番号を，そのまま割込み番号として使
用している．また，割込みハンドラ番号は，それに対応する割込み番号と一致
させている．GICがサポートする割込みの種類と，その割込み番号の範囲は次
の通り．

	0〜15				ソフトウェア生成割込み（SGI）
	16〜31				コア毎のペリフェラルからの割込み（PPI）
	32〜1019（最大）	共有ペリフェラルからの割込み（SPI）

GIC依存部では，割込み要求ラインの標準のトリガモードの設定をサポートし
ている．ただし，SGIに対しては，トリガモードを設定することができない．
また，PPIに対してトリガモードを設定できるかは，チップに依存する（いず
れも，コンフィギュレータはエラーを検出しない）．

GIC依存部では，TOPPERS第3世代カーネル（ITRON系）統合仕様書の規定に合致
した割込み要求禁止フラグをサポートしており，dis_intとena_intをサポート
している．ただし，SGIに対する割込み要求禁止フラグがサポートされるかは，
チップに依存する（dis_intとena_intはエラーを検出しない）．

また，GIC依存部では，割込み要求のクリア，割込みの要求，割込み要求のチェッ
クをサポートしており，clr_int，ras_int，prb_intをサポートしている．た
だし，SGIに対する割込み要求のクリアはサポートおらず（GICのバージョンに
よってはサポートできないため），SGIに対してclr_intを呼び出すとE_PARエ
ラーとなる．レベルトリガの割込み要求ラインに対しても，ras_intで割込み
を要求することができ，clr_intは，ras_intで要求した割込み要求のみをクリ
アする（ハードウェアから要求された割込みはクリアできない）．

2.2.2 RZ/A1チップ依存部における割込み処理に関する規定

RZ/Aシリーズの割込みコントローラは，GICに独自の制御回路を追加したもの
になっており，32レベルの割込み優先度をサポートしている．そのため，割込
み優先度の最小値（最高値）は-31，割込み優先度の最大値（最低値）は-1で
ある．

RZ/Aシリーズの割込みコントローラがサポートする割込みの種類と，その割込
み番号の範囲は次の通り（個別の割込みについては，チップのマニュアルを参
照すること）．

	ソフトウェア割込み			0〜15
	CPUからの割込み				16〜19
	IRQ割込み					32〜39
	内蔵周辺モジュール割込み	40〜415
	端子割込み					416〜537（RZ/A1Lの場合）
								416〜586（RZ/A1H，RZ/A1Mの場合）

CPUからの割込みと内蔵周辺モジュール割込みは，レベルトリガで使用するかエッ
ジトリガで使用するかが，チップで決められている．チップでの指定と異なる
設定をした場合の動作は保証されない（異なる設定をしても，エラーにはなら
ない）．チップでの指定については，チップのマニュアルを参照すること．

IRQ割込みについては，GICの手前に独自の割込み入力制御回路が入っており，
その制御レジスタで，レベルトリガ，ポジティブエッジトリガ，ネガティブエッ
ジトリガ，両エッジトリガのいずれにするかを設定することができる．そこで，
IRQ割込みに対する割込み要求ラインの属性の設定（CFG_INT）では，以下のター
ゲット定義の割込み要求ライン属性を指定することができる．

	TA_NEGEDGE		0x04U		ネガティブエッジトリガ
	TA_POSEDGE		0x08U		ポジティブエッジトリガ
	TA_BOTHEDGE		0x0cU		両エッジトリガ

IRQ割込みに対してTA_EDGEを指定した場合，それ以外の割込みに対して上の3つ
の属性を指定した場合は，コンフィギュレータがエラーを検出する．

また，IRQ割込みをエッジトリガで使用する場合に，カーネルは，トリガした割
込み要求をクリアしない（カーネルの標準的な振舞いと異なる）．それに代え
て，トリガした割込み要求をクリアするための以下の関数を用意している．

(2-2-2-1) void rza1_clear_irq(INTNO intno)

intnoで指定したIRQ割込み要求をクリアする．intnoに指定できる値は，
INTNO_IRQ0〜INTNO_IRQ7の範囲である．

IRQ割込みに対するclr_int，ras_int，prb_intは，GICを操作して実現してお
り，独自の制御回路は操作しない．そのため，カーネルの標準的な振舞いと異
なるため，注意が必要である．

2.3 CPU例外処理に関する規定

CPU例外ハンドラ番号は，以下のように割り当てている．

	EXCNO_UNDEF		0		未定義命令
	EXCNO_SVC		1		スーパバイザコール
	EXCNO_PABORT	2		プリフェッチアボート
	EXCNO_DABORT	3		データアボート
	EXCNO_IRQ		4		IRQ割込み
	EXCNO_FIQ		5		FIQ割込み

この内，EXCNO_IRQに対しては，DEF_EXCによりCPU例外ハンドラを登録すること
ができない．

ARMでは，CPU例外ハンドラからリターンする場合に，戻り先のプログラムカウ
ンタの補正が必要になる．補正量は，例外の種類や，例外の原因になった命令
を再実行するかその次の命令から実行するかによって，以下の通りとなる．

例外の種類				戻り番地								補正量
----------------------------------------------------------------------
未定義命令				未定義命令の番地						−4/2(*)
						未定義命令の次の命令の番地				±0
スーパバイザコール		SVCの次の命令の番地						±0
プリフェッチアボート	アボートされた命令の番地				−4
						アボートされた命令の次の命令の番地		±0
データアボート			アボートを生成した命令の番地			−8
						アボートを生成した命令の次の命令の番地	−4
FIQ割込み				次に実行すべき番地						−4
----------------------------------------------------------------------
(*) ARMモードでは4，Thumbモードでは2

CPU例外ハンドラ内で戻り番地を補正する場合，以下のようなコードを実行すれ
ばよい（以下の例は，補正量が-4の場合）．

	((T_EXCINF *) p_excinf)->pc -= 4U

CPU例外ハンドラを登録していないCPU例外が発生した場合，デフォルトのCPU例
外ハンドラが実行される．ターゲット依存部で変更していない場合，デフォル
トのCPU例外ハンドラでは，発生したCPU例外の種類と，CPU例外の発生状況をシ
ステムログに出力する．詳しくは，「3.2 CPU例外の原因の追及方法」の節を参
照すること．

2.4 タイマに関する規定

2.4.1 MPCoreチップ依存部におけるタイマに関する規定

MPCoreチップ依存部では，コア毎に持つプライベートタイマとプライベート
ウォッチドッグを用いて，高分解能タイマを実現している．

プライベートタイマとプライベートウォッチドッグのクロック源の周波数が
256MHz以下の場合には，プリスケーラを用いて1MHzのクロックを作り，プライ
ベートタイマとプライベートウォッチドッグを1MHzで駆動する．この場合には，
ターゲット依存部でchip_timer.hをインクルードする前に，次の2つのマクロ
を定義する必要がある．

	MPCORE_TMR_PS_VALUE		タイマのプリスケーラの設定値
	MPCORE_WDG_PS_VALUE		ウォッチドッグのプリスケーラの設定値

これらのプリスケーラの設定値は，分周比（クロック源のMHz単位での周波数）
から1を減じたものに定義する（つまり，上の2つのマクロには，同じ値を定義
することになる）．

この時，高分解能タイマの周期は2^32（TCYC_HRTCNTは定義しない），カウン
トアップの進み幅（TSTEP_HRTCNT）は1となる．

プライベートタイマとプライベートウォッチドッグのクロック源の周波数が
256MHzを超える場合には，プリスケーラで1MHzのクロックを作ることができな
い．そこで，プリスケーラで作ることができる1MHzの倍数の周波数（これを，
N MHzとする）を選び，プライベートタイマとプライベートウォッチドッグをN
MHzで駆動する．高分解能タイマは1マイクロ秒に1のペースでカウントアップ
しなければならないため，高分解能タイマのタイマ周期（TCYC_HRTCNT）は，
2^32/N（小数点以下は切り捨て）になる．

ここで，Nが2のべき乗でない場合に，高分解能タイマに誤差が出る．これを防
ぐために，高分解能タイマのタイマ周期を作っているプライベートウォッチドッ
グの周期を，高分解能タイマのタイマ周期のN倍（言い換えると，2^32以下で
最も大きいNの倍数）にする．

プライベートタイマとプライベートウォッチドッグをN MHzで駆動する場合に
は，target_kernel.h（または，そこからインクルードされるファイル）にお
いて，次のマクロを定義する．

	TCYC_HRTCNT				高分解能タイマのタイマ周期

また，ターゲット依存部でchip_timer.hをインクルードする前に，上の2つの
マクロに加えて，次の3つのマクロを定義する必要がある．

	MPCORE_WDG_LR_VALUE		ウォッチドッグのリロード値
	MPCORE_WDG_FREQ			ウォッチドッグの駆動周波数
	MPCORE_TMR_FREQ			タイマの駆動周波数

ウォッチドッグのリロード値は，プライベートウォッチドッグの周期から1を
減じたもの（すなわち，TCYC_HRTCNT * N - 1）に定義し，ウォッチドッグと
タイマの駆動周波数は，Nに定義する（つまり，MPCORE_WDG_FREQと
MPCORE_TMR_FREQには，同じ値を定義することになる）．

例えば，プライベートタイマとプライベートウォッチドッグを5MHzで駆動する
（すなわち，N＝5）場合には，target_kernel.hにおいて，

#define TCYC_HRTCNT				858993459		/* floor(2^32/5) */

また，ターゲット依存部でchip_timer.hをインクルードする前に，

#define MPCORE_WDG_LR_VALUE		4294967294		/* TCYC_HRTCNT * 5 - 1 */
#define MPCORE_WDG_FREQ			5
#define MPCORE_TMR_FREQ			5

のマクロ定義を行う（他に，MPCORE_TMR_PS_VALUEとMPCORE_WDG_PS_VALUEの定
義も必要である）．

2.4.2 RZ/A1チップ依存部におけるタイマに関する規定

RZ/A1チップ依存部では，RZ/Aシリーズが持つ2チャンネルのOSタイマの内の1つ
（OSタイマ0）を用いて高分解能タイマを，もう1つ（OSタイマ1）を用いてオー
バランタイマを実現している．

現在の実装では，OSタイマに供給されるクロックが33.33…MHz（CPUのクロック
が400MHz）の場合のみに対応している．この場合，高分解能タイマの周期
（TCYC_HRTCNT）は128,849,019（2^32÷33.33…を丸めた値），カウントアップ
の進み幅（TSTEP_HRTCNT）は1である．また，オーバランハンドラの残りプロセッ
サ時間に指定できる最大値（TMAX_OVRTIM）は128,849,017である．

2.5 その他の規定・制約

タスクと非タスクコンテキスト用のスタック領域の先頭番地とサイズは，8の倍
数でなければならない．固定長メモリプール領域の先頭番地は，4の倍数でなけ
ればならない．

割込みハンドラの先頭番地（DEF_INHのinthdr）とCPU例外ハンドラの先頭番地
（DEF_EXCのexchdr）がプログラムの開始番地として正しくない場合のエラーは，
コンフィギュレータによって検出される．

それに対して，割込みサービスルーチンの先頭番地（CRE_ISRのisr），初期化
ルーチンの先頭番地（ATT_INIのinirtn），終了処理ルーチンの先頭番地
（ATT_TERのterrtn）がプログラムの開始番地として正しくない場合のエラーは，
コンフィギュレータによって検出されない．

2.6 動的生成機能拡張のサポートに関する規定

動的生成機能拡張パッケージをサポートしている．

動的メモリ管理は，オープンソースのメモリ割付けライブラリであるTLSFを用
いる方法を標準にしている．そのため，動的生成機能拡張を使用する場合には，
TLSFのパッケージに含まれるtlsf.hとtlsf.cを，カーネルをビルドするディレ
クトリか，vpathで指定されたディレクトリに置いておく必要がある．また，
MakefileのKERNEL_COBJSの定義に，以下のようにtlsf.oを追加する必要がある．

----------------------------------------
KERNEL_COBJS := $(KERNEL_COBJS) tlsf.o
----------------------------------------

なお，TLSF（動作確認は，Version 2.4.6）は，以下のウェブサイトからダウン
ロードすることができる．

	http://www.gii.upv.es/tlsf/


３．使用上の注意とヒント

3.1 MMUの設定

MMUを持つチップでは，MMUを使用しないとキャッシュを使用することができな
い．そこで，ARMコア依存部では，有効なアドレスに対して，論理アドレスと物
理アドレスが一致するような変換テーブルを準備し，それを使用するように設
定する．

有効なアドレスの範囲と，各アドレス範囲におけるMMUへの設定属性（許可する
アクセスの種類，キャッシュの設定等）は，ターゲット依存部で定義する．

MPCoreとRZ/AシリーズはMMUを持つため，MPCoreチップ依存部やRZ/A1チップ依
存部を使用する場合には，上記の設定となる．

3.2 CPU例外の原因の追及方法

CPU例外ハンドラを登録していないCPU例外が発生すると，デフォルトのCPU例外
ハンドラ（default_exc_handler）が実行される。SUPPORT_XLOG_SYSを定義して
いる場合（ターゲット依存部で定義していることが多い），デフォルトのCPU例
外ハンドラは，発生したCPU例外の種類と，CPU例外の発生状況をシステムログ
に出力する。以下では，CPU例外の種類毎に，CPU例外の原因を追及する方法に
ついて説明する。

(1) 未定義命令例外

システムログに出力されるプログラムカウンタ（pc）の値は，未定義命令の次
の命令の番地である。その手前にある未定義命令を実行したことが，CPU例外の
原因である。

(2) スーパバイザコール（SVC）例外

システムログに出力されるプログラムカウンタ（pc）の値は，svc命令の次の命
令の番地である。その手前にあるsvc命令を実行したことが，CPU例外の原因で
ある。

(3) プリフェッチアボート

システムログに出力されるプログラムカウンタ（pc）の値は，(アボートされた
命令フェッチの番地+4)である。

プリフェッチアボートは，不正な番地への分岐によって起こるのが一般的であ
るが，その場合，プログラムカウンタの値は，(分岐先の番地+4)となる。CPU例
外の発生原因は分岐元の命令であるが，システムログに出力される情報から分
岐元を知る方法はない。ただし，関数呼出しによる分岐の場合には，リンクレ
ジスタ（lr）に戻り番地が保存されるため，リンクレジスタが指す命令の手前
の分岐命令が，CPU例外の原因ということになる。

プリフェッチアボート発生の詳しい状況は，ARMv7では，CP15の
IFSR（Instruction Fault Status Register）やIFAR（Instruction Fault
Address Register）を読み出すことが必要である。

(4) データアボート

システムログに出力されるプログラムカウンタ（pc）の値は，(データアボート
を起こした命令番地+8)である。(プログラムカウンタの値-8)の番地にある命令
を実行したことが，CPU例外の原因である。

特殊な状況として，CPU例外がカーネル内（dabort_handler内であることが一般
的）で発生し，システムログに出力されるnest_countが異常な値（INT32_MIN近
辺の値）になっている場合がある。これは，スタックポインタが不正な値になっ
た状態でCPU例外が発生し，カーネル内で必要な情報をスタックに保存しようと
して再度CPU例外が発生した状況である。この場合，CPU例外が起こった状況が
保存されていないため，CPU例外の原因の追及は難しい。

データアボート発生の詳しい状況は，CP15のDFSR（Data Fault Status
Register）やDFAR（Data Fault Address Register，ARMv6以前はFARの名称，
ARMv6より前はIFARと統合されている）を読み出すことが必要である。

(5) アボート発生の状況

ARMv7では，以下のレジスタが用意されている。

	DFSR（Instruction Fault Status Register）	cp15 c5 0 c0 0
	DFAR（Instruction Fault Address Register）	cp15 c6 0 c0 0
	IFSR（Instruction Fault Status Register）	cp15 c5 0 c0 1
	IFAR（Instruction Fault Address Register）	cp15 c6 0 c0 2

ARMv6は，ARMv6の持つ4つのレジスタ内，IFARはオプションである。また，
DFARはFAR（Fault Address Register）と呼ばれている。

ARMv5以前は，以下のレジスタが用意されている。

	FSR（Fault Status Register）	cp15 c5 0 c0 0
	FAR（Fault Address Register）	cp15 c6 0 c0 0

3.3 パフォーマンスモニタによる性能評価

ARMv7に準拠したパフォーマンスモニタを持つターゲットシステムでは，
USE_ARM_PM_HISTを定義してコンパイルすることで，実行時間分布集計サービス
において，パフォーマンスモニタを用いて実行時間を計測する．実行時間の計
測単位は，0.1マイクロ秒としている．


４．リファレンス

4.1 ディレクトリ構成・ファイル構成

	arm_gcc/
		MANIFEST				個別パッケージのファイルリスト

	arm_gcc/common/
		Makefile.core			Makefileのコア依存部
		arm.c					コアのハードウェア資源の操作
		arm.h					コアのハードウェア資源の定義
		arm_insn.h				コア独自の命令の実行
		core_asm.inc			アセンブラ記述のためのマクロ
		core_cfg1_out.h			cfg1_out.cのリンクに必要なスタブの定義
		core_check.trb			kernel_check.trbのコア依存部
		core_kernel.h			kernel.hのコア依存部
		core_kernel.trb			kernel.trbのコア依存部
		core_kernel_impl.c		カーネル実装のコア依存部関連の定義
		core_kernel_impl.h		カーネル実装のコア依存部
		core_offset.trb			genoffset.trbのコア依存部
		core_rename.def			コア依存部の内部識別名のリネーム定義
		core_rename.h			コア依存部の内部識別名のリネーム
		core_sil.h				sil.hのコア依存部
		core_stddef.h			t_stddef.hのコア依存部
		core_support.S			カーネル実装のコア依存部（アセンブリ言語
								で記述した部分）
 		core_sym.def			kernel_sym.defのコア依存部
		core_syssvc.h			システムサービスのコア依存定義
		core_test.h				テストプログラムのコア依存定義
		core_unrename.h			コア依存部の内部識別名のリネーム解除
		gic_kernel_impl.c		カーネル実装のGIC依存部関連の定義
		gic_kernel_impl.h		カーネル実装のGIC依存部
		gic_support.S			カーネル実装のGIC依存部関連（アセンブリ言
								語で記述した部分）
		pl310.c					L2キャッシュコントローラ（PL310）の操作ライ
								ブラリ
		pl310.h					L2キャッシュコントローラ（PL310）に関する定義
		sp804.h					ARM Dual-Timer Module（SP804）に関する定義
		start.S					カーネル用のスタートアップモジュール（ARM用）
		tUartPL011.c			ARM PrimCell UART（PL011）用 簡易SIOドライバ
		tUartPL011.cdl			ARM PrimCell UART（PL011）用 簡易SIOドライ
								バのコンポーネント記述
		uart_pl011.h			ARM PrimCell UART（PL011）に関する定義

	arm_gcc/mpcore/
		MANIFEST				MPCore依存部のファイルリスト
		Makefile.chip			Makefileのチップ依存部
		chip_kernel.h			kernel.hのチップ依存部
		chip_kernel_impl.c		カーネル実装のチップ依存部関連の定義
		chip_kernel_impl.h		カーネル実装のチップ依存部
		chip_rename.def			チップ依存部の内部識別名のリネーム定義
		chip_rename.h			チップ依存部の内部識別名のリネーム
		chip_stddef.h			t_stddef.hのチップ依存部
		chip_timer.c			タイマドライバ
		chip_timer.cfg			タイマドライバのコンフィギュレーションファイル
		chip_timer.h			タイマドライバを使用するための定義
		chip_unrename.h			チップ依存部の内部識別名のリネーム解除
		mpcore.h				チップのハードウェア資源の定義

	arm_gcc/rza1/
		MANIFEST				RZ/A1依存部のファイルリスト
		Makefile.chip			Makefileのチップ依存部
		chip_kernel.h			kernel.hのチップ依存部
		chip_kernel.trb			kernel.trbのチップ依存部
		chip_kernel_impl.c		カーネル実装のチップ依存部関連の定義
		chip_kernel_impl.h		カーネル実装のチップ依存部
		chip_rename.def			チップ依存部の内部識別名のリネーム定義
		chip_rename.h			チップ依存部の内部識別名のリネーム
		chip_stddef.h			t_stddef.hのチップ依存部
		chip_sym.def			kernel_sym.defのチップ依存部
		chip_timer.c			タイマドライバ
		chip_timer.cfg			タイマドライバのコンフィギュレーションファイル
		chip_timer.h			タイマドライバを使用するための定義
		chip_unrename.h			チップ依存部の内部識別名のリネーム解除
		rza1.h					チップのハードウェア資源の定義
		scif.h					シリアルインタフェースに関する定義
		tSCIF.c					シリアルインタフェース用 簡易SIOドライバ
		tSCIF.cdl				シリアルインタフェース用 簡易SIOドライバ
								のコンポーネント記述

	arm_gcc/doc/
		arm_design.txt			ARMコア依存部 設計メモ
		arm_user.txt			ARM依存部 ユーザーズマニュアル
		gic_design.txt			GIC依存部 設計メモ

4.2 バージョン履歴

	2015年8月5日	Release	3.B.0		最初のリリース
	2016年2月8日	Release	3.0.0		最初の一般公開
	2016年5月15日	Release	3.1.0		RZ/A1のサポートを追加
	2017年7月21日	Release	3.2.0

以上
